from flask import *import sslimport socketfrom datetime import *import dns.resolverimport dns.ednsimport dns.flagsimport hashlibimport osimport binasciifrom queue import Queue, Emptyimport paramiko as pmimport utilfrom forms import *app = Flask(__name__)app.debug = Trueapp.secret_key = os.urandom(24)@app.route('/')def main():    return render_template('main.html')@app.route('/overview')def overview():    return render_template('overview.html')@app.route('/https', methods=['GET', 'POST'])def https():    form = HostForm()    result = None    if request.method == 'POST' and form.validate():        result = {}        host = form.host.data        port = form.port.data        result['host'] = host        result['port'] = port        c, dc = get_cert(host, port)        result['cert'] = _get_cert_data(c)        result['hash'], result['tlsa'] = _get_tlsa(host, port, dc)    else:        form.port.data = 443    return render_template('https.html', form=form, result=result)@app.route('/smtp', methods=['GET', 'POST'])def smtp():    form = HostForm()    result = None    if request.method == 'POST' and form.validate():        result = {}        host = form.host.data        port = form.port.data        result['host'] = host        result['port'] = port        c, dc = get_cert_smtp(host, port)        result['cert'] = _get_cert_data(c)        result['hash'], result['tlsa'] = _get_tlsa(host, port, dc)    else:        form.host.data = 'mainframe.dafcorp.net'        form.port.data = 25    return render_template('smtp.html', form=form, result=result)@app.route('/sshfp', methods=['GET', 'POST'])def sshfp():    form = HostForm()    form.port.data = 22    result = None    return render_template('sshfp.html', form=form, result=result)def _get_context():    return ssl.create_default_context(cafile='ca/ca-sha2.pem')def _get_field(s, d):    for t in d:        if t[0][0] == s:            return t[0][1]def _get_cert_data(c):    result = {}    result['from_d'] = datetime.strptime(c['notBefore'], "%b %d %H:%M:%S %Y %Z")    result['to_d'] = datetime.strptime(c['notAfter'], "%b %d %H:%M:%S %Y %Z")    result['cn'] = _get_field('commonName', c['subject'])    result['an'] = ", ".join([x[1] for x in c['subjectAltName'] if x[0] == 'DNS'])    return resultdef _get_tlsa(host, port, dc):    try:        a = get_resolver().query("_%s._tcp.%s." % (port, host), 'TLSA')        for ans in a:            if ans.selector == 0:  # full cert                if ans.mtype == 1:  # SHA256                    return hashlib.sha256(dc).hexdigest(), binascii.hexlify(a[0].cert).decode()                elif ans.mtype == 2:  # SHA512                    return hashlib.sha512(dc).hexdigest(), binascii.hexlify(a[0].cert).decode()        return 'TLSA ERROR' * 2    except dns.resolver.NoAnswer:        return 'NO ANSWER' * 2    except dns.resolver.NXDOMAIN:        return ['NXDOMAIN'] * 2@app.template_global()def get_cert_smtp(host, port):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))    s.setblocking(False)    q = Queue()    got_tls = False    starttls_sent = False    with util.PollThread(s, q) as t:        t.start()        while True:            try:                l = q.get_nowait()            except Empty:                if got_tls and not starttls_sent:                    s.send(b'STARTTLS\r\n')                    starttls_sent = True                else:                    pass            else:                if l.startswith('220 2.0.0'):                    t.join()                    break                elif l.startswith('220'):                    s.send(b'EHLO 87-249-184-71.ljusnet.se\r\n')                elif l.startswith('250-STARTTLS'):                    got_tls = True        s.setblocking(True)        ssl_context = _get_context()        ssl_context.check_hostname = False        ssl_sock = ssl_context.wrap_socket(s)        c = ssl_sock.getpeercert()        dc = ssl_sock.getpeercert(binary_form=True)        ssl_sock.close()        return c, dc@app.template_global()def get_cert(host, port):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    ssl_context = _get_context()    ssl_context.check_hostname = True    ssl_sock = ssl_context.wrap_socket(s, server_hostname=host)    ssl_sock.connect((host, port))    c = ssl_sock.getpeercert()    dc = ssl_sock.getpeercert(binary_form=True)    ssl_sock.close()    return c, dc@app.template_global()def get_ssh_key(host, port):    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)    s.connect((host, port))    t = pm.Transport(s)    t.start_client()    k = t.get_remote_server_key()    t.close()    s.close()    return k, hashlib.sha256(k.asbytes()).hexdigest()def get_resolver():    r = dns.resolver.Resolver()    r.use_edns(0, dns.flags.DO, 1280)    return r@app.template_global()def get_tlsa(host, port):    try:        a = get_resolver().query("_%s._tcp.%s." % (port, host), 'TLSA')        return binascii.hexlify(a[0].cert).decode()    except dns.resolver.NoAnswer:        return 'noanswer'@app.template_global()def get_sshfp(host, key):    try:        a = get_resolver().query("%s" % host, 'SSHFP')        # key_type = -1        if type(key) is pm.rsakey.RSAKey:            key_type = 1        elif type(key) is pm.dsskey.DSSKey:            key_type = 2        elif type(key) is pm.ecdsakey.ECDSAKey:            key_type = 3        else:            return 'ogiltigtyp'        for r in a:            if r.algorithm == key_type and r.fp_type == 2:                return binascii.hexlify(r.fingerprint).decode()        return 'detsketsig'    except dns.resolver.NoAnswer:        return 'noanswer'@app.template_global()def is_none(test):    return test is None@app.template_filter('df')def df(d):    return d.strftime('%Y-%m-%d')@app.template_filter('join')def join_filter(a):    return ', '.join(a)if __name__ == '__main__':    app.run(host='0.0.0.0', port=80)